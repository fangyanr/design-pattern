# design-pattern
一、单例模式：
1 单例模式有两种常见的实现方式，被称为饿汉式和懒汉式。
饿汉式：加载类的时候就初始化一个实例。
懒汉式：加载类的时候不初始化，当第一次使用实例时才初始化。
2 单例类的特点总结：
1)构造方法是private权限，保证其他类无法创建该类实例，只能该类自身创建
2)声明一个static修饰的自身实例，保证该实例永远只是一个
3)提供一个public方法，返回定义的static自身实例 

二、适配器模式
1 适配器模式分类
1)类形式的适配器——使用继承实现适配器模式(is a)
2)实例形式的适配器——使用关联实现适配器模式(has a)
2 适配器模式把一个类的接口变换成客户端所期待的另一种接口。
  适配器模式使原本无法在一起工作的两个类能够在一起工作。
3 类结构
目标(Target)：就是我们所期待得到的接口。注意，由于这里讨论的是类变压器模式，因此目标不可以是类，而是接口。
源(Adaptee)：现有需要适配的接口。
变压器(Adapter)：变压器类是本模块的核心。变压器把源接口转换成目标接口。显然，这一角色不可以是接口，而必须是实类。
  
三、装饰器模式
1 概述
装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案。
装饰模式可以在不使用创造更多子类的情况下，将对象的功能加以扩展。
装饰模式使用原来被装饰的类的一个子类的实例，把客户端的调用委派到被装饰类。
2 类结构
抽象构件(Component)：给出一个抽象接口，以规范准备接受附加责任的对象。
具体构件(ConcreteComponent)：定义一个将要接收附加责任的类。
装饰(Decorator)：持有一个构件(Component)对象的实例，并定义一个与抽象构件接口一致的接口。
具体装饰(ConcreteDecorator)：负责给构件对象“贴上”附件的责任。
3 应用场景：
1)需要扩展一个类的功能，或给一个类增加附加责任。
2)需要动态地给一个对象增加功能，这些功能可以再动态地撤销。
3)需要增加由一些基本功能的排列组合而产生的非常大量的功能，从而使继承关系变得不现实。

四、代理模式
1 概述
所谓代理，就是一个人或者一个机构代表另一个人或者另一个机构采取行动。
在一些情况下，一个客户不想或者不能够直接引用一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用，进行额外的预处理和后续处理。
2 类结构
抽象主题角色(Subject)：声明了真实主题和代理主题的共同接口，这样在任何可用真实主题的地方都可以使用代理主题。
代理主题角色(Proxy)：代理主题角色内部含有对真实主题的引用，从而可以在任何时候操作真实主题对象，代理角色通常在将客户端调用传递给真实的主题之前或之后，都要执行某个操作。
真实主题角色(RealSubject)：定义了代理角色所代表的真实对象。

五、职责链模式
1 概述
使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

六、迭代器模式
1 概述
提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。

  
  



